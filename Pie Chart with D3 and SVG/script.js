/* JS Setup Instructions */

// call a function to include an arbitrary set of numbers in an array
let dataset = randomData();
// include an arbitrary set of colors to pair with each item in the data array
const datasetColors = ["#8AC9E1", "#e83a30", "#02C08A", "#F7CC58", "#e88c30"];

// call a function based on the dataset which produces an array with the degrees describing the cumulative weight of the numbers described in the dataset array
// input: array of numbers
// output: array of cumulative degrees
let datasetDegrees = datasetFromNumbersToDegrees(dataset);

// reverse the dataset and the dataDegrees arrays
// this as to draw each slice on top of the previous one
// input: array
// output: reversed array
reverseArray(dataset);
reverseArray(datasetDegrees);



/* JS Functions Definitions */

// define a function which returns an array of five items, five random numbers
function randomData() {
    let arr = [];
    for(let i=0; i < 5; i++) {
        arr.push(Math.floor(Math.random()*50));
    }
    return arr;
}

// define a function which takes as input an array of numbers and outputs an array with the equivalent amount in degrees, describing the cumulative distribution
function datasetFromNumbersToDegrees(arr) {
    // compute the total from the array of numbers
    const total = arr.reduce((a,b) => a + b);

    // include in an array the percentage weight of the numbers (computed as number/total)
    const arrPercent = arr.map((a) => a/total);

    // include an array the cumulative percentage 
    const arrCumulative = [arrPercent[0]];

    for(let i = 1; i < arrPercent.length; i++) {
        let cumulative = arrPercent[i] + arrCumulative[i-1];
        arrCumulative.push(cumulative);
    }

    // convert the percentage to a degree value (ranging between 0 and 360)
    const arrDegrees = arrCumulative.map((a) => a*360);
    return arrDegrees;
}

// define a function which sorts an array from highest to lowest
function reverseArray(arr) {
    arr.reverse();
}



/* D3 Instructions */

// append an svg in the .container__chart div
// as width and height are defined in relation to the viewbox, changing the width of the svg scales the entire structure
const pieChart = d3
                    .select(".container .container__chart")
                    .append("svg")
                    // d3js uses camelCase when including the attribute of viewbox
                    .attr("viewBox", "0 0 100 100")
                    .attr("width", 100)
                    .attr("height", 100);

// call a function which draws a circle in the defined SVG
// draw the circle of the color (fill) of the last slice (as this is not drawn, the circle visually supplements it)
drawCircle(dataset, datasetColors[0]);


/* call a function which draws the pie chart's slices, specifying 
- which numbers to include 
- which degrees to include (the numbers are included as text, the degrees are used to draw the correct size of the slices)
- the colors of the path elements
*/
drawSlices(dataset, datasetDegrees, datasetColors);





/* D3.JS Functions Definitions */

// define a function which draws a circle, in the element specified by the first argument and of a color specified by th second argument 
function drawCircle(data, colorLastSlice) {
    // draw a circle covering the entire SVG
    // the data retrieved fromt the dataset is drawn incrementally as a slice of the circle
    // the last slice is not drawn (the path element for this particular portion goes round 360 degrees, removing the visual) 
    // because of this, the circle is both used as a frame and as the color for the last, final slice
    pieChart
        .append("circle")
        .attr("cy", 50)
        .attr("cx", 50)
        .attr("r",50)
        .attr("fill", colorLastSlice)
        .attr("class", "slice")
        // include as a title element the number which the circle represents
        .append("title")
        .text(data[0]);
}

// define a function which draws a path element made of an arc command, to draw the slices of the cake on the basis of the arrays of numbers and degrees included
function drawSlices(data, dataDegrees, dataColors) {
    // include a path element for each number included in the dataset array
    pieChart
        .selectAll("path")
        .data(data)
        .enter()
        .append("path")
        .attr("d", (d, i) => {
            // the path uses an arc to draw a section of a circle; the syntax closely resembles the following:
            // "M 50 50 L 50 0 A 50 50 0 0 1 100 50"
            // start from the center, draw a vertical line to the top of the circle, draw an arc of radii 50 50 toward a selected point, which in this instance is 100 50
            // the actual coordinate of the point is computed with a bit of trigonometry on the basis of the angle generated by the data points
            // the arc command accepts also three flags (the 0 and 1 values). These stand for x-rotation, long-sweep arc, mirror arc 
            // prior to completing a semi-circle, the flags 0 0 1 allow to describe correctly a section of the circle
            // following this threshold, the flags 0 1 1 allow to continue with the pattern set earlier (and maintain a clockwise pattern) 
            let flags = (dataDegrees[i] > 180) ? '0 1 1' : '0 0 1';

            // the x and y coordinates of the final point are obtained with a bit of trigonometry using the sine and cosine functions
            // JS has two functions bearing a similar name, but they accept radians instead of degrees, so a conversion is warranted
            // radians = degree * pi / 180

            // the x coordinate is computed multiplying the radius of the circle (50) by the sine of the angle
            // As the origin of the circle is (50, 50) and not (0,0), the value obtained through the sine function needs to be incremented by 50
            let xCoor = 50 + Math.sin(dataDegrees[i] * Math.PI / 180) * 50;

            // the y coordinate is computed multiplying the cosine function by the same angle.
            // as the origin is (50,50), this value is deducted from 50 to retrieve the actual vertical coordinate
            let yCoor = 50 - Math.cos(dataDegrees[i] * Math.PI / 180) * 50;         
            return `M 50 50 L 50 0 A 50 50 ${flags} ${xCoor} ${yCoor}`;
        })
        .attr("fill", (d,i) => dataColors[i])
        .attr("class", "slice")
        // include as title element the number each path element represents
        .append("title")
        .text((d) => d);
}


// listen to a click event on the main button, at which point display a new pie chart
const refreshButton = document.querySelector(".container .container__refresh");
refreshButton.addEventListener("click", refreshChart);

// define a function which goes through the process of setting a new pie chart on the basis of a new set of random numbers
function refreshChart() {
    removeSVGElements();
    dataset = randomData();
    datasetDegrees = datasetFromNumbersToDegrees(dataset);
    reverseArray(dataset);
    reverseArray(datasetDegrees);

    drawCircle(dataset, datasetColors[0]);
    drawSlices(dataset, datasetDegrees, datasetColors);
}

// define a function which removes the circle and path elements from the SVG
// otherwise: a circle element will be appended on the SVG after the path elements. Moreover, path elements would not be included anew, as the selectAll method would identify the existing path elements
function removeSVGElements() {
    pieChart.selectAll("circle").remove();
    pieChart.selectAll("path").remove();
}