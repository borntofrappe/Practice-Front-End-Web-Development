// target the single div in the HTML document
const container = d3.select(".container");



// HTML ELEMENTS
// include introductory elements in a wrapping container
const containerHTML = container
  .append("div")
  .attr("class", "container__html");

containerHTML
  .append("h1")
  .attr("id", "title")
  .text("Sweet Data Viz");

containerHTML
  .append("h3")
  .attr("id", "description")
  .text("Bake Sale Results*");

containerHTML
  .append("p")
  .attr("id", "asterisk")
  .text("*lollipops and pies by top sellers");

// include also a tooltip, but in the main container
const tooltip = container
  .append("div")
  .attr("id", "tooltip")
  .style("opacity", "0");



// DATA
// include an array with 12 random values
let randomArr = [];
let max = 20,
  min = 5;

for(let i = 0; i < 12; i++) {
  randomArr.push(Math.floor(Math.random() * (max-min)) + min);
}

// sort the array items from biggest to smallest 
// (they'd be automatically sorted for a pie layout, but for a lollipop plot, it is advisable to sort them ahead of time)
const sortedArr = randomArr.sort((a, b) => b - a);



// SVG FRAME
/* for the SVG element(s), define the margin and width/height values as per the habitual conventione
- create an svg element 
- nest in the element a g group element, translated inside of the parent element by a measure equal to the margin
- include the visualization in this last element, without fear of cropping 
*/
const margin = {
  top: 20,
  right: 20,
  bottom: 20,
  // include additional margin to display the cardinal numbers in the ticks' labels
  left: 30
};

// include the each visualization in a squared frame
const width = 500 - margin.left - margin.right;
const height = 500 - margin.top - margin.bottom;


// LOLLIPOP PLOT
// include the svg and g elements following the mentioned convention
const svgLollipopPlot = container 
  .append("svg")
  .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
  .attr("class", "container__svg")
  .append("g")
  .attr("transform", `translate(${margin.left}, ${margin.top})`);


// SCALES
// include scales based on the data
// the axes are then plotted on the basis of these scales, but **after** the elements making up the visualization, to have the axes on top of the path elements

// horizontally, the lollipop plot displays lines spanning the width according to the data points values, and the xScale therefore accounts for such values in the domain 
const xScale = d3
  .scaleLinear()
  .domain([0, max])
  .range([0, width]);

// vertically, the lollipop plot divides the space in equal bands for each data points, and specifies therefore an ordinal scale
const yScale = d3
  .scaleBand()
  // ordinal scale accepts in the domain an array, which is automatically generated by d3.range()
  // d3.range(3) --> [0, 1, 2]
  .domain(d3.range(sortedArr.length))
  .range([0, height]);


// PATHS AND CIRCLES
// include a group element for each data point
// inside of these wrapping elements, path and circle elements will be included immediately afterwards
// this allows to include mouse events on both path and circle elements more concisely 
const lollipop = svgLollipopPlot
  .selectAll("g.lollipop")
  .data(sortedArr)
  .enter()
  .append("g")
  .attr("class", "lollipop")
  // on mouseenter display the tooltip including text pertaining to the data point
  .on("mouseenter", (d) => {
    tooltip
      .style("opacity", "1")
      .style("top", `${d3.event.layerY}px`)
      .style("left", `${d3.event.layerX}px`)
      .text(`${d}k`);
  })
  // on mouseleave, hide the tooltip back
  .on("mouseleave", () => tooltip.style("opacity", "0"));

// on each wrapping g element included for each data point include a path and a circle element
// please note: it is possible to also use a line element, which may be actually simpler
lollipop
  .append("path")
  // with path syntax: start the path where the tick lies (based on the scale and offsetting for the band's own width)
  // move the path horizontally according to the data point values (weighed by the respective scale)
  // transition the path to this value from M 0 0
  .attr("d", (d, i) => `M 0 ${yScale(i) + yScale.bandwidth() / 2} h 0`)
  .transition()
  .duration(1000)
  // transition each element one after the other
  .delay((d, i) => 100 + 150 * i)
  .attr("d", (d, i) => `M 0 ${yScale(i) + yScale.bandwidth() / 2} h ${xScale(d)}`);

lollipop
  .append("circle")
  .attr("r", 8)
  // position the circles right where the path elements end
  .attr("cy", (d, i) => yScale(i) + yScale.bandwidth() / 2)
  // transition them horizontally and jointly with the path elements
  .attr("cx", (d) => 0)
  .transition()
  .duration(1000)
  .delay((d, i) => 100 + 150 * i)
  .attr("cx", (d) => xScale(d));


// AXES
// include axes based on the scales, **after** the g, path, circle elements to have the axes lie on top
const xAxis = d3
  .axisBottom(xScale)
  // inclulde a thousand mark for all ticks expect for 0
  .tickFormat((d, i) => (i !== 0) ? `${d}k` : d);

const yAxis = d3 
  .axisLeft(yScale)
  // remove ticks and include a number for each label (starting at 1 instead of 0)
  .tickSize(0)
  .tickPadding(10)
  // include a cardinal number detailing specific use cases for 1st, 2nd and 3rd
  .tickFormat((d) => (d+1 === 1) ? `${d+1}st` : (d+1 === 2) ? `${d+1}nd` : (d+1 === 3) ? `${d+1}rd` : `${d+1}th`);

svgLollipopPlot
  .append("g")
  .attr("class", "axis")
  .attr("transform", `translate(0, ${height})`)
  .call(xAxis);

svgLollipopPlot
  .append("g")
  .attr("class", "axis")
  .call(yAxis);


// PIE CHART
// include an the svg and g elements as for the lollipop plot
const svgPieChart = container 
  .append("svg")
  .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
  .attr("class", "container__svg")
  .append("g")
  .attr("transform", `translate(${margin.left}, ${margin.top})`);

// include the pie function, which details the startAngle and endAngle for each data point based on its value
const pie = d3 
  .pie();

// include a scale, to alter the outer radius of each slice according to its value
const radiusScale = d3 
  .scaleLinear()
  // map the smallest to the biggest data point
  .domain(d3.extent(sortedArr))
  // map from a fourth of the width to a half (a half of the width allows the pie chart to draw at most until the edge of the svg element)
  .range([width/4, width/2]);

// include an arc function which is used for each data point to detail the d attribute of each path element
// please note: while the innerRadius is given a fixed value, the outerRadius is given a value dependant on the data point
// d.data as the data point is first passed to the d3.pie() function
// d3.pie() indeed formats the array into objects with several values
// console.log(pie(sortedArr));
const arc = d3
  .arc()
  .innerRadius(width / 10)
  .outerRadius((d) => radiusScale(d.data));

// for each data point (passed through the pie function to obtain relevant information) append a group element
const arcs = svgPieChart
  .selectAll("g")
  .data(pie(sortedArr))
  .enter()
  .append("g")
  // center the containers in the middle of the svg 
  .attr("transform", `translate(${width/ 2}, ${width/ 2})`);

// in each wrapping element, include a path element, which includes the slices in the d attribute and through the arc function
arcs
  .append("path")
  .attr("class", "slice")
  // on mouseenter display the tooltip including text pertaining to the data point
  .on("mouseenter", (d) => {
    tooltip
      .style("opacity", "1")
      .style("top", `${d3.event.layerY}px`)
      .style("left", `${d3.event.layerX}px`)
      .text(`${d.data}k`);
  })
  // on mouseleave, hide the tooltip back
  .on("mouseleave", () => tooltip.style("opacity", "0"))
  .attr("d", arc);

